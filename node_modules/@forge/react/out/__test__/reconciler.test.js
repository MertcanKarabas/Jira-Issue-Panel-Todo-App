"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const jsx_runtime_1 = require("react/jsx-runtime");
let keyCount = 0;
jest.mock('uuid', () => (Object.assign(Object.assign({}, jest.requireActual('uuid')), { v4: () => `${keyCount++}` })));
const resetKeyCount = () => {
    keyCount = 0;
};
const react_1 = tslib_1.__importStar(require("react"));
const reconcilerTestRenderer_1 = tslib_1.__importDefault(require("./reconcilerTestRenderer"));
const components_1 = require("../components");
const get_1 = tslib_1.__importDefault(require("lodash/get"));
const testUtils_1 = require("./testUtils");
describe('Reconcilation', () => {
    resetKeyCount();
    let bridgeCalls = [];
    const TEXT = 0;
    const BUTTON = 1;
    const STATIC_TEXT = 2;
    const STRING = 0;
    beforeAll(async () => {
        bridgeCalls = (0, testUtils_1.setupBridge)();
        const Test = () => {
            const [bool, setBool] = (0, react_1.useState)(false);
            return ((0, jsx_runtime_1.jsxs)(react_1.default.Fragment, { children: [(0, jsx_runtime_1.jsx)(components_1.Text, { children: !bool ? 'Loading...' : 'Now loaded...' }), (0, jsx_runtime_1.jsx)(components_1.Button, Object.assign({ onClick: () => setBool(true) }, { children: "Click" })), (0, jsx_runtime_1.jsx)(components_1.Lozenge, Object.assign({ appearance: "inprogress" }, { children: "Test" }))] }));
        };
        resetKeyCount();
        await reconcilerTestRenderer_1.default.create((0, jsx_runtime_1.jsx)(Test, {}));
    });
    it('forgeDoc is created on initial render', () => {
        const forgeDoc = (0, testUtils_1.getLastBridgeCallForgeDoc)(bridgeCalls);
        expect(forgeDoc).toHaveProperty(`children[${TEXT}].type`, 'Text');
        expect(forgeDoc).toHaveProperty(`children[${BUTTON}].type`, 'Button');
        expect(forgeDoc).toHaveProperty(`children[${STATIC_TEXT}].type`, 'Lozenge');
        expect(forgeDoc).toMatchSnapshot();
    });
    it('forgeDoc is updated on state update', () => {
        let forgeDoc = (0, testUtils_1.getLastBridgeCallForgeDoc)(bridgeCalls);
        const onClick = (0, get_1.default)(forgeDoc, `children[${BUTTON}].props.onClick`);
        expect(onClick).not.toBeUndefined();
        onClick();
        forgeDoc = (0, testUtils_1.getLastBridgeCallForgeDoc)(bridgeCalls);
        expect(forgeDoc).toHaveProperty(`children[${TEXT}].children[${STRING}].type`, 'String');
        expect(forgeDoc).toHaveProperty(`children[${TEXT}].children[${STRING}].props.text`, 'Now loaded...');
        expect(forgeDoc).toMatchSnapshot();
    });
});
describe('deep tree reconciliation', () => {
    let bridgeCalls = [];
    beforeAll(async () => {
        bridgeCalls = (0, testUtils_1.setupBridge)();
        const Test = () => {
            const [count, setCount] = (0, react_1.useState)(0);
            function incrementCount() {
                setCount(count + 1);
            }
            return ((0, jsx_runtime_1.jsx)(react_1.default.Fragment, { children: (0, jsx_runtime_1.jsxs)(components_1.Inline, { children: [(0, jsx_runtime_1.jsx)(components_1.Stack, { children: (0, jsx_runtime_1.jsx)(components_1.Text, { children: count }) }), (0, jsx_runtime_1.jsxs)(components_1.Stack, { children: [(0, jsx_runtime_1.jsx)(components_1.Text, { children: "Should not update" }), (0, jsx_runtime_1.jsx)(components_1.Button, Object.assign({ onClick: incrementCount }, { children: "Click" }))] })] }) }));
        };
        resetKeyCount();
        await reconcilerTestRenderer_1.default.create((0, jsx_runtime_1.jsx)(Test, {}));
    });
    it('should match the initially rendered ForgeDoc snaphot', () => {
        const forgeDoc = (0, testUtils_1.getLastBridgeCallForgeDoc)(bridgeCalls);
        expect(forgeDoc).toMatchSnapshot();
    });
    it('should match snapshot after triggering update', () => {
        var _a, _b;
        let forgeDoc = (0, testUtils_1.getLastBridgeCallForgeDoc)(bridgeCalls);
        expect(forgeDoc).not.toBeNull();
        const button = (0, testUtils_1.findElementInForgeDoc)(forgeDoc, '8');
        expect(button).not.toBeUndefined();
        expect((_a = button === null || button === void 0 ? void 0 : button.props) === null || _a === void 0 ? void 0 : _a.onClick).not.toBeUndefined();
        (_b = button === null || button === void 0 ? void 0 : button.props) === null || _b === void 0 ? void 0 : _b.onClick();
        forgeDoc = (0, testUtils_1.getLastBridgeCallForgeDoc)(bridgeCalls);
        expect(forgeDoc).toMatchSnapshot();
    });
});
describe('macro config', () => {
    it('should create forgeDoc tree for macro config', async () => {
        const bridgeCalls = (0, testUtils_1.setupBridge)();
        const App = () => {
            return ((0, jsx_runtime_1.jsx)(react_1.default.Fragment, { children: (0, jsx_runtime_1.jsx)(components_1.Text, { children: "Hello World" }) }));
        };
        const Config = () => {
            return (0, jsx_runtime_1.jsx)(components_1.Textfield, { name: "age" });
        };
        await reconcilerTestRenderer_1.default.create((0, jsx_runtime_1.jsx)(App, {}));
        await reconcilerTestRenderer_1.default.addConfig((0, jsx_runtime_1.jsx)(Config, {}));
        const configForgeDoc = (0, testUtils_1.getLastBridgeCallForgeDoc)(bridgeCalls);
        expect(configForgeDoc === null || configForgeDoc === void 0 ? void 0 : configForgeDoc.type).toEqual('MacroConfig');
        expect(configForgeDoc === null || configForgeDoc === void 0 ? void 0 : configForgeDoc.children[0].type).toEqual('Textfield');
    });
});
describe('id props', () => {
    let bridgeCalls = [];
    beforeAll(async () => {
        bridgeCalls = (0, testUtils_1.setupBridge)();
        const Test = () => {
            return ((0, jsx_runtime_1.jsxs)(react_1.default.Fragment, { children: [(0, jsx_runtime_1.jsx)(components_1.Label, Object.assign({ labelFor: "username" }, { children: "username" })), (0, jsx_runtime_1.jsx)(components_1.Textfield, { id: "username", placeholder: "name" }), (0, jsx_runtime_1.jsx)(components_1.DatePicker, { id: "datepicker", placeholder: "date" })] }));
        };
        await reconcilerTestRenderer_1.default.create((0, jsx_runtime_1.jsx)(Test, {}));
    });
    it('should contain a prefix', () => {
        const forgeDoc = (0, testUtils_1.getLastBridgeCallForgeDoc)(bridgeCalls);
        expect(forgeDoc).toHaveProperty('children[0].props.labelFor', 'forge-app-0-username');
        expect(forgeDoc).toHaveProperty('children[1].props.id', 'forge-app-0-username');
        expect(forgeDoc).toHaveProperty('children[2].props.id', 'forge-app-0-datepicker');
    });
    it('should still contain other props', () => {
        const forgeDoc = (0, testUtils_1.getLastBridgeCallForgeDoc)(bridgeCalls);
        expect(forgeDoc).toHaveProperty('children[1].props.placeholder', 'name');
        expect(forgeDoc).toHaveProperty('children[2].props.placeholder', 'date');
    });
});
describe('function props __id__ attributes', () => {
    let bridgeCalls = [];
    beforeAll(async () => {
        bridgeCalls = (0, testUtils_1.setupBridge)();
        const Test = () => {
            const [count, setCount] = (0, react_1.useState)(0);
            function incrementCount() {
                setCount(count + 1);
            }
            return ((0, jsx_runtime_1.jsx)(react_1.default.Fragment, { children: (0, jsx_runtime_1.jsxs)(components_1.Inline, { children: [(0, jsx_runtime_1.jsx)(components_1.Stack, { children: (0, jsx_runtime_1.jsx)(components_1.Text, { children: count }) }), (0, jsx_runtime_1.jsxs)(components_1.Stack, { children: [(0, jsx_runtime_1.jsx)(components_1.Button, Object.assign({ appearance: "danger", onClick: incrementCount }, { children: "Click" })), (0, jsx_runtime_1.jsx)(components_1.Stack, { children: (0, jsx_runtime_1.jsx)(components_1.Button, Object.assign({ autoFocus: true, onClick: () => setCount(0) }, { children: "Reset" })) })] })] }) }));
        };
        resetKeyCount();
        await reconcilerTestRenderer_1.default.create((0, jsx_runtime_1.jsx)(Test, {}));
    });
    it('should contain __id__ attribute for all function props', () => {
        const forgeDoc = (0, testUtils_1.getLastBridgeCallForgeDoc)(bridgeCalls);
        expect((0, testUtils_1.findElementInForgeDoc)(forgeDoc, '6')).toHaveProperty('props.onClick.__id__', '5');
        expect((0, testUtils_1.findElementInForgeDoc)(forgeDoc, '9')).toHaveProperty('props.onClick.__id__', '8');
    });
    it('should not contain __id__ attribute for non function props', () => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        const forgeDoc = (0, testUtils_1.getLastBridgeCallForgeDoc)(bridgeCalls);
        expect((_b = (_a = (0, testUtils_1.findElementInForgeDoc)(forgeDoc, '6')) === null || _a === void 0 ? void 0 : _a.props) === null || _b === void 0 ? void 0 : _b.appearance).toBe('danger');
        expect((_e = (_d = (_c = (0, testUtils_1.findElementInForgeDoc)(forgeDoc, '6')) === null || _c === void 0 ? void 0 : _c.props) === null || _d === void 0 ? void 0 : _d.appearance) === null || _e === void 0 ? void 0 : _e.__id__).toBeUndefined();
        expect((_g = (_f = (0, testUtils_1.findElementInForgeDoc)(forgeDoc, '9')) === null || _f === void 0 ? void 0 : _f.props) === null || _g === void 0 ? void 0 : _g.autoFocus).toBe(true);
        expect((_k = (_j = (_h = (0, testUtils_1.findElementInForgeDoc)(forgeDoc, '9')) === null || _h === void 0 ? void 0 : _h.props) === null || _j === void 0 ? void 0 : _j.autoFocus) === null || _k === void 0 ? void 0 : _k.__id__).toBeUndefined();
    });
});
