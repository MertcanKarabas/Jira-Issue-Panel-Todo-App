"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ForgeReconciler = exports.hostConfig = exports.nonChildPropsAreEqual = exports.insertBefore = exports.appendChild = exports.createElement = exports.callBridge = void 0;
const tslib_1 = require("tslib");
const react_reconciler_1 = tslib_1.__importDefault(require("react-reconciler"));
const constants_1 = require("react-reconciler/constants");
const uuid_1 = require("uuid");
const idPropsPrefixAppUUID = (0, uuid_1.v4)().slice(0, 5);
const idPropsPrefix = `forge-app-${idPropsPrefixAppUUID}`;
const newPropsWithIdPrefix = (props) => {
    const idProps = ['id', 'labelFor', 'inputId'];
    const newProps = idProps.reduce((acc, idProp) => {
        if (props[idProp]) {
            return Object.assign(Object.assign({}, acc), { [idProp]: `${idPropsPrefix}-${props[idProp]}` });
        }
        return acc;
    }, props);
    return newProps;
};
const attachFunctionPropId = (props) => {
    for (const key in props) {
        const propValue = props[key];
        if (typeof propValue === 'function' && !propValue.__id__) {
            propValue.__id__ = (0, uuid_1.v4)();
        }
    }
    return props;
};
const callBridge = function (cmd, data) {
    var _a;
    (_a = self === null || self === void 0 ? void 0 : self.__bridge) === null || _a === void 0 ? void 0 : _a.callBridge(cmd, data);
};
exports.callBridge = callBridge;
const createElement = ({ type, props = {}, forgeReactMajorVersion }) => {
    const { children } = props, restProps = tslib_1.__rest(props, ["children"]);
    const newProps = newPropsWithIdPrefix(attachFunctionPropId(restProps));
    const element = {
        type,
        children: [],
        props: newProps,
        key: (0, uuid_1.v4)()
    };
    if (forgeReactMajorVersion) {
        element.forgeReactMajorVersion = forgeReactMajorVersion;
    }
    return element;
};
exports.createElement = createElement;
const appendChild = (parent, child) => {
    if (parent.children.includes(child)) {
        const removeIndex = parent.children.indexOf(child);
        parent.children.splice(removeIndex, 1);
    }
    parent.children.push(child);
};
exports.appendChild = appendChild;
const insertBefore = (parent, child, beforeChild) => {
    const insertIndex = parent.children.indexOf(beforeChild);
    if (parent.children.includes(child)) {
        const removeIndex = parent.children.indexOf(child);
        parent.children.splice(removeIndex, 1);
    }
    parent.children.splice(insertIndex, 0, child);
};
exports.insertBefore = insertBefore;
const nonChildPropsAreEqual = (oldProps, newProps) => {
    const newPropsKey = Object.keys(newProps).filter((key) => key !== 'children');
    const oldPropsKey = Object.keys(oldProps).filter((key) => key !== 'children');
    if (newPropsKey.length !== oldPropsKey.length) {
        return false;
    }
    for (const key of newPropsKey) {
        if (newProps[key] !== oldProps[key]) {
            return false;
        }
    }
    return true;
};
exports.nonChildPropsAreEqual = nonChildPropsAreEqual;
exports.hostConfig = {
    supportsMutation: true,
    supportsPersistence: false,
    noTimeout: -1,
    isPrimaryRenderer: false,
    supportsHydration: false,
    resetAfterCommit(containerInfo) {
        (0, exports.callBridge)('reconcile', { forgeDoc: containerInfo });
    },
    createInstance(type, instanceProps) {
        const element = (0, exports.createElement)({ type, props: instanceProps });
        return element;
    },
    createTextInstance(text) {
        const element = (0, exports.createElement)({ type: 'String', props: { text } });
        return element;
    },
    appendInitialChild(parentInstance, child) {
        (0, exports.appendChild)(parentInstance, child);
    },
    appendChild(parent, child) {
        (0, exports.appendChild)(parent, child);
    },
    appendChildToContainer(container, child) {
        (0, exports.appendChild)(container, child);
    },
    finalizeInitialChildren() {
        return false;
    },
    prepareUpdate(instance, type, oldProps, newProps) {
        instance.props = newProps;
        return newProps;
    },
    shouldSetTextContent() {
        return false;
    },
    getRootHostContext() {
        return {};
    },
    getChildHostContext() {
        return null;
    },
    getPublicInstance(instance) {
        return instance;
    },
    prepareForCommit() {
        return null;
    },
    preparePortalMount() { },
    scheduleTimeout(fn, delay) {
        return setTimeout(fn, delay);
    },
    cancelTimeout(id) {
        clearTimeout(id);
    },
    insertBefore(parentInstance, child, beforeChild) {
        (0, exports.insertBefore)(parentInstance, child, beforeChild);
    },
    insertInContainerBefore(container, child, beforeChild) {
        (0, exports.insertBefore)(container, child, beforeChild);
    },
    removeChild(parent, child) {
        const removeIndex = parent.children.indexOf(child);
        parent.children.splice(removeIndex, 1);
    },
    removeChildFromContainer(container, child) {
        const removeIndex = container.children.indexOf(child);
        container.children.splice(removeIndex, 1);
    },
    resetTextContent() { },
    commitTextUpdate(textInstance, oldText, newText) {
        textInstance.props.text = newText;
    },
    commitMount() { },
    commitUpdate() { },
    hideInstance() { },
    hideTextInstance() { },
    unhideInstance() { },
    unhideTextInstance() { },
    clearContainer() { },
    detachDeletedInstance() { },
    getCurrentEventPriority() {
        return constants_1.DefaultEventPriority;
    },
    getInstanceFromNode() {
        return null;
    },
    beforeActiveInstanceBlur() { },
    afterActiveInstanceBlur() { },
    prepareScopeUpdate() { },
    getInstanceFromScope() {
        return null;
    }
};
const reconciler = (0, react_reconciler_1.default)(exports.hostConfig);
exports.ForgeReconciler = {
    render: (element) => {
        const rootElement = (0, exports.createElement)({ type: 'Root', props: {}, forgeReactMajorVersion: 10 });
        const container = reconciler.createContainer(rootElement, 0, null, false, null, 'root', (err) => {
            console.log(err);
        }, null);
        reconciler.updateContainer(element, container, null, null);
    },
    addConfig: (element) => {
        const macroConfigElement = (0, exports.createElement)({ type: 'MacroConfig', props: {}, forgeReactMajorVersion: 10 });
        const container = reconciler.createContainer(macroConfigElement, 0, null, false, null, 'macroConfig', (err) => {
            console.log(err);
        }, null);
        reconciler.updateContainer(element, container, null, null);
    }
};
exports.default = exports.ForgeReconciler;
