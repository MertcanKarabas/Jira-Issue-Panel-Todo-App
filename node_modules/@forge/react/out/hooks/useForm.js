"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useForm = void 0;
const tslib_1 = require("tslib");
const react_1 = require("react");
const react_hook_form_1 = require("react-hook-form");
const get_1 = tslib_1.__importDefault(require("lodash/get"));
function useForm(props = {}) {
    const id = (0, react_1.useId)();
    const getFieldId = (fieldName) => {
        return `form-${id}-${fieldName}`;
    };
    const { register, formState, handleSubmit, setValue, getValues, trigger, clearErrors } = (0, react_hook_form_1.useForm)({
        defaultValues: props.defaultValues,
        mode: 'onBlur',
        reValidateMode: 'onChange'
    });
    const defaultValues = props === null || props === void 0 ? void 0 : props.defaultValues;
    const forgeFormRegister = (fieldName, options) => {
        const _a = register(fieldName, {
            required: options === null || options === void 0 ? void 0 : options.required,
            disabled: options === null || options === void 0 ? void 0 : options.disabled,
            maxLength: options === null || options === void 0 ? void 0 : options.maxLength,
            minLength: options === null || options === void 0 ? void 0 : options.minLength,
            max: options === null || options === void 0 ? void 0 : options.max,
            min: options === null || options === void 0 ? void 0 : options.min,
            pattern: options === null || options === void 0 ? void 0 : options.pattern,
            validate: options === null || options === void 0 ? void 0 : options.validate
        }), { onChange, ref, required, disabled } = _a, rest = tslib_1.__rest(_a, ["onChange", "ref", "required", "disabled"]);
        const additionalProps = {};
        if (defaultValues) {
            if (typeof (0, get_1.default)(defaultValues, fieldName) === 'boolean') {
                additionalProps.defaultChecked = (0, get_1.default)(defaultValues, fieldName);
            }
            else {
                additionalProps.defaultValue = (0, get_1.default)(defaultValues, fieldName);
            }
        }
        const isError = !!(0, get_1.default)(formState, `errors["${fieldName}"]`);
        const onChangeOptions = {
            shouldDirty: true,
            shouldValidate: formState.submitCount > 0 || !!(0, get_1.default)(formState, `touchedFields["${fieldName}"]`)
        };
        return Object.assign(Object.assign(Object.assign({}, rest), { onChange: (event) => {
                var _a, _b;
                if (((_a = event === null || event === void 0 ? void 0 : event.target) === null || _a === void 0 ? void 0 : _a.type) === 'checkbox') {
                    return Promise.resolve(setValue(fieldName, event.target.checked, onChangeOptions));
                }
                if (['number', 'text', 'textarea', 'radio', 'password'].includes((_b = event === null || event === void 0 ? void 0 : event.target) === null || _b === void 0 ? void 0 : _b.type)) {
                    return Promise.resolve(setValue(fieldName, event.target.value, onChangeOptions));
                }
                else {
                    return Promise.resolve(setValue(fieldName, event, onChangeOptions));
                }
            }, isInvalid: isError, 'aria-invalid': isError, id: getFieldId(fieldName), isDisabled: disabled }), additionalProps);
    };
    return {
        getFieldId,
        register: forgeFormRegister,
        formState: {
            errors: formState.errors,
            isSubmitted: formState.isSubmitted,
            isSubmitSuccessful: formState.isSubmitSuccessful,
            isSubmitting: formState.isSubmitting,
            submitCount: formState.submitCount,
            isValid: formState.isValid,
            dirtyFields: formState.dirtyFields,
            touchedFields: formState.touchedFields
        },
        handleSubmit,
        getValues,
        trigger,
        clearErrors
    };
}
exports.useForm = useForm;
